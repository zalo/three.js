<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - reprojection</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				touch-action: none;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js webgl</a> - materials - reprojection<br/>
			Rendering CAVE Imagery to <a href="http://paulbourke.net/dome/mirrordome/" target="_blank" rel="noopener">a Paul Bourke-style Mirror Dome</a>
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="x-shader/x-vertex" id="vertexshader">

			varying vec2 vUv;
			uniform bool previewOnScreen;
			uniform mat4 eyeProjectionMatrix, eyeViewMatrix; 

			void main() {

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

				vec4 modelViewLocal = ( modelMatrix * eyeViewMatrix ) * vec4( position, 1.0 );
				vec4    screenLocal = eyeProjectionMatrix * modelViewLocal;
				vUv                 = ( ( screenLocal.xy / screenLocal.w ) + 1.0 ) * 0.5;
				if ( previewOnScreen ) { gl_Position = vec4( ( uv - 0.5 ) * 2.0, 0.0, 1.0 ); }

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			varying vec2 vUv;
			uniform sampler2D map;

			void main() {

				bool outsideUV =  max(vUv.x, vUv.y) > 1.0 || min(vUv.x, vUv.y) < 0.0;
				gl_FragColor = outsideUV ? vec4(0.0, 0.0, 0.0, 1.0) : texture2D( map, vUv );

				#include <tonemapping_fragment>
				#include <encodings_fragment>
				#include <dithering_fragment>

			}

		</script>


		<script type="module" >

			import * as THREE from 'three';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
			import * as CameraUtils from 'three/addons/utils/CameraUtils.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
			import Stats from 'three/addons/libs/stats.module.js';

			let camera, scene, renderer, stats;
			let cube, sphere, dome, curvedPanel, material;
			let raycaster;
			let lineGeometry = new THREE.BufferGeometry();
			let lineMaterial = new THREE.LineBasicMaterial( {transparent: true, opacity: 0.35 } );
			let lineSegments;

			let eyeCamera, eyeRenderTarget, eyeCameraHelper, params = { mirrorSphereRadius: 23, enableInterpolatedNormals: true };

			let controls;

			init();

			function init() {

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setAnimationLoop(animation);
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				document.body.appendChild(renderer.domElement);

				window.addEventListener('resize', onWindowResized);

				stats = new Stats();
				document.body.appendChild(stats.dom);

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
				camera.position.x = 200;
				camera.position.y = 150;
				camera.position.z = 0;
				scene.add(camera);

				new RGBELoader()
					.setPath('textures/equirectangular/')
					.load('quarry_01_1k.hdr', function (texture) {
						texture.mapping = THREE.EquirectangularReflectionMapping;
						scene.background = texture;
						scene.environment = texture;
						sphere.material = new THREE.MeshBasicMaterial( { envMap: texture } );
					});

				//

				eyeRenderTarget = new THREE.WebGLRenderTarget(1024, 576);
				eyeRenderTarget.texture.type = THREE.HalfFloatType;
				eyeRenderTarget.texture.encoding = renderer.outputEncoding;

				eyeCamera = new THREE.PerspectiveCamera(30, 16.0 / 9.0, 1, 200);
				scene.add(eyeCamera);
				eyeCameraHelper = new THREE.CameraHelper(eyeCamera);
				scene.add(eyeCameraHelper);

				//

				material = new THREE.ShaderMaterial( {
					side: THREE.BackSide,
					uniforms: {
						map                 : { value: eyeRenderTarget.texture      },
						eyeProjectionMatrix : { value: eyeCamera.projectionMatrix   },
						eyeViewMatrix       : { value: eyeCamera.matrixWorldInverse },
						previewOnScreen     : { value: false                        }
					},
					vertexShader  : document.getElementById(   'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent

				} );


				const material2 = new THREE.MeshStandardMaterial( {
					roughness: 0.1,
					metalness: 0
				} );

				cube = new THREE.Mesh( new THREE.BoxGeometry( 15, 15, 15 ), material2 );
				cube.position.x = 0;
				cube.position.y = 30;
				cube.position.z = 100;
				scene.add( cube );

				sphere = new THREE.Mesh( new THREE.SphereGeometry( 1, 32, 16 ), material2 );
				sphere.name = "sphere";
				sphere.position.x = 0.0;
				sphere.position.y = 0.0;
				sphere.position.z = -30;
				sphere.scale.set(params.mirrorSphereRadius, params.mirrorSphereRadius, params.mirrorSphereRadius);
				scene.add( sphere );

				dome = new THREE.Mesh( new THREE.SphereGeometry( 250, 32, 16 ), new THREE.MeshStandardMaterial( {
					roughness: 0.1,
					metalness: 0,
					side: THREE.BackSide
				} ));
				dome.name = "dome";
				dome.visible = false;
				scene.add( dome );

				sphere.updateMatrixWorld();
				sphere.updateWorldMatrix();
				raycaster = new THREE.Raycaster()

				curvedPanel = new THREE.Mesh(createCurvedPanelGeometry(), material);
				scene.add(curvedPanel);
				lineSegments = new THREE.LineSegments( lineGeometry, lineMaterial );
				scene.add(lineSegments);

				const gui = new GUI();
				gui.add(renderer, 'toneMappingExposure', 0, 2).name('Exposure');
				gui.add(eyeCamera, 'fov', 0, 60).name('FoV');
				gui.add(params, 'mirrorSphereRadius', 23, 30).onChange(() => {
					curvedPanel.geometry = createCurvedPanelGeometry();
				}).name('Mirror Sphere Radius');
				gui.add(material.uniforms.previewOnScreen, 'value', false).name('Preview').onChange((preview)=>{
					material.side = preview ? THREE.FrontSide : THREE.BackSide;
				});
				gui.add(params, 'enableInterpolatedNormals', true).onChange(() => {
					curvedPanel.geometry = createCurvedPanelGeometry();
				}).name("Use Interpolated Normals");
				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target = new THREE.Vector3(0, 50, 100);
			}

			function createCurvedPanelGeometry( ) {

				sphere.scale.set(params.mirrorSphereRadius, params.mirrorSphereRadius, params.mirrorSphereRadius);

				let curvedPanelGeometry = new THREE.PlaneGeometry(16, 9, 16, 16);
				let vertices = curvedPanelGeometry.getAttribute("position").array;
				let tempVec1 = new THREE.Vector3(), tempVec2 = new THREE.Vector3();
				let index = 0, indices = [], positions = [];
				for (let i = 0; i < vertices.length; i += 3) {
					raycaster.set(tempVec1.set(0, 0, 30), 
								  tempVec2.set(vertices[i]+0.00001, vertices[i+1]+5, vertices[i+2]-30).normalize());
					let intersects = raycaster.intersectObjects( [sphere] );
					if(intersects.length > 0){
						vertices[i    ] = intersects[0].point.x;
						vertices[i + 1] = intersects[0].point.y;
						vertices[i + 2] = intersects[0].point.z;
						positions.push(0, 0, 30, vertices[i], vertices[i + 1], vertices[i + 2]); indices.push(index, index+1); index += 2;
					
						//console.log(intersects[0]);
						let normal = (params.enableInterpolatedNormals ? intersects[0].normal : intersects[0].face.normal).normalize();
						raycaster.set(intersects[0].point, normal);
						intersects = raycaster.intersectObjects( [dome] );
						if(intersects.length > 0){
							positions.push(vertices[i], vertices[i + 1], vertices[i + 2], intersects[0].point.x, intersects[0].point.y, intersects[0].point.z); indices.push(index, index+1); index += 2;
							vertices[i    ] = intersects[0].point.x;
							vertices[i + 1] = intersects[0].point.y;
							vertices[i + 2] = intersects[0].point.z;
						}else{
							console.log("WHAT THE HECK HAPPENED?!", normal)
						}
					}

				}

				lineGeometry.setIndex( indices );
				lineGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				//lineGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				lineGeometry.computeBoundingSphere();
				lineGeometry.needsUpdate = true;
				if(lineSegments){
					lineSegments.needsUpdate = true;
				}

				return curvedPanelGeometry;
			}

			function onWindowResized() {

				renderer.setSize( window.innerWidth, window.innerHeight );

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

			}

			function animation( msTime ) {

				const time = msTime / 1000;

				// move the eye's perspective around to make it interesting
				eyeCamera.position.x = Math.cos( ( 2.0 + time ) * 0.5 ) * 30;
				eyeCamera.position.y = Math.sin( ( 2.0 + time ) * 0.25 ) * 5;
				eyeCamera.position.z = 30 + Math.sin( ( 2.0 + time ) ) * 20;
				eyeCamera.lookAt( new THREE.Vector3(0, 30, 100) );

				// save the original camera properties
				const currentRenderTarget = renderer.getRenderTarget();
				const currentXrEnabled = renderer.xr.enabled;
				const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
				renderer.xr.enabled = false; // Avoid camera modification
				renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows

				// update the FoV of the eye camera
				eyeCamera.updateProjectionMatrix();

				// set up rendering from the eye's camera
				renderer.setRenderTarget( eyeRenderTarget );
				renderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897
				if ( renderer.autoClear === false ) renderer.clear();
				curvedPanel    .visible = false; // hide the curvedPanel from from the eye's camera
				eyeCameraHelper.visible = false;
				lineSegments   .visible = false;

				// render the eye's perspective to eyeRenderTarget
				renderer.render( scene, eyeCamera );

				// restore the original rendering properties
				lineSegments   .visible = true;
				curvedPanel    .visible = true;
				eyeCameraHelper.visible = true;
				renderer.xr.enabled = currentXrEnabled;
				renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
				renderer.setRenderTarget( currentRenderTarget );

				eyeCameraHelper.update();

				controls.update();

				renderer.render( scene, camera );

				stats.update();

			}

		</script>

	</body>
</html>
